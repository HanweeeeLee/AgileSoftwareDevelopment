# 20. 패키지 설계의 원칙

커다란 애플리케이션을 조직화할 때는 클래스보다 패키지를 사용하는게 유리하다.

## 패키지를 위한 설계?
UML에서 패키지는 클래스들을 담는 그릇으로 쓰임  
클래스가 다른 클래스에 의존 관계를 갖는 경우도 많으며, 이런 의존 관계가 패키지를 넘어서는 일도 많음  
이런것들을 관리하는게 우리의 역할.  
  
우리의 의문점 
 - 클래스를 패키지로 할당할 때 따를 원칙들은 무엇인가?
 - 어떤 설계 원칙들이 패키지 사이의 의존 관계를 지배하는가?
 - 클래스보다 패키지를 먼저 설계해야 하는가(하향식). 아니면 클래스를 먼저 설계해야 하는가(상향식).
 - 패키지는 물리적으로 어떻게 표현해야 하는가? C++에서는 어떻게 하고, 자바에서는 어떻게 하는가? 또 개발 환경에서는 어떻게 하는가?
 - 패키지를 만들었다면, 이 패키지들을 어떤 목적으로 사용해야 하는가?
  
  
## 단위 크기: 패키지 응집도의 원칙
이 원칙을 적용하기 전 클래스와 클래스 상호 관계가 일부분이라도 밝혀져 있어야 한다. 즉 이 원칙들은 '상향식' 접근 방법임  

### 재사용 릴리즈 등가 원칙(REP)
**재사용의 단위가 릴리즈의 단위다.**  

재사용하려고 하는 클래스 라이브러리의 작성자에게 무엇을 바랄까?  
 - 작성자가 그 코드를 유지보수해주기를 바란다.
 - 작성자가 코드의 인터페이스나 기능을 바꾸기 전에 미리 통보해주기를 바란다. 또한, 새로운 버전을 거부할 수 있는 선택권을 주어야한다.  

두번째 문제는 근본적으로 정치적이다. 하지만 이런 정치적이고 사무적인 문제가 소프트웨어의 패키지에는 영향을 많이 끼침.  
재사용 릴리즈 등가 원칙(REP: Reuse-Release Equivalence Principle)에 따르면 재사용 단위는 릴리즈 단위보다 작을 수 없다.  
재사용하는 모든 것은 반드시 릴리즈된 다음 추적되어야 한다. -> 개발자가 그냥 클래스 하나 달랑 만들고 재사용 가능하다고 주장하는 것은 아니라는 뜻.  
잠재적인 재사용자들에게 필요한 통보, 안전성, 지원에 대한 보장을 제공하는 추적시스템이 먼저 있은 다음에야 재사용성이라는 말을 할 수 있다.  
  
재사용성은 반드시 패키지에 기반을 두어야 하기 때문에, 재사용 가능한 패키지는 재사용 가능한 클래스를 포함해야 한다.  
패키지의 모든 클래스가 재사용 가능하든지, 모두 그렇지 않든지 해야한다.  
재사용성이 유일한 기준은 아니다. 컨테이너 클래스 라이브러리와 금융 관련 프레임워크는 둘 다 분명히 재사용 가능하지만, 이들을 하나의 패키지에 넣어서는 안된다.  
금융에만 관심있고, 컨테이너에는 관심이 없는 사람이 있을것이기 때문에. 그러므로 사용자 관점에서 바라보아야 한다.  

### 공통 재사용 원칙(CRP)
**패키지 안의 클래스들은 함께 재사용되어야 한다. 어떤 패키지의 클래스 하나를 재사용한다면 나머지 모두 재사용한다.**  

공통 재사용 원칙(CRP: Common-Reuse Principle)은 어떤 클래스들이 패키지에 포함되어야 하는 지 결정할 때 도움이 된다.  
자주 함께 재사용되는 클래스들은 동일한 패키지에 속해 있어야 한다.  
하지만 CRP가 어떤 클래스들을 같은 패키지에 넣어야 한다는 것만 말하지 않음. 어떤 클래스를 같은 패키지에 넣지 않아야 할지도 말해준다.  
패키지에 넣는 클래스들이 서로 관계가 하나라도 있다면 의존성이 생긴 것. 이건 생각보다 복잡한 이야기가 될 수 있음.  
따라서 어떤 패키지에 의존한다면 그 패키지의 모든 클래스에 의존하는지 확실히 해두어야 한다.  

### 공통 폐쇄 원칙(CCP)
**같은 패키지 안의 클래스들은 동일한 종류의 변화에는 모두 폐쇄적이어야 한다. 패키지에 어떤 변화가 영향을 미친다면, 그 변화는 그 패키지의 모든 클래스에 영향을 미쳐야 하고 다른 패키지에는 영향을 미치지 않아야 한다.**  
  
대상이 패키지인 단일책임원칙(SRP)임. 클래스를 변경할 이유가 여러 가지면 안 된다는 SRP와 마찬가지로, 패키지를 변경할 이유도 여러 가지면 안 됨.  
이 원칙은 개방 폐쇄 원칙(OCP)과도 밀접한 관련이 있다. 이 원칙이 다루는 대상이 OCP에서 의미하는 '폐쇄'이기 때문임.  
  
  
## 안정성: 패키지 결합도의 원칙
### 의존 관계 비순환 원칙(ADP)
**패키지 의존성 그래프에서 순환을 허용하지 말라.**
하루 종일 일해서 어떤 것을 작동하게 만든 다음, 집에 갔다 다음 날 다시 와보니 그것이 또 작동을 안한다? -> 다음 날 아침 증후군  
다음 날 아침 증후군은 많은 개발자가 동일한 소스 파일들을 고치는 개발 환경에서 일어난다.  
지난 몇십 년 동안, 이 문제에 대한 두 가지 해결 방법이 발전해왔다. 
1. 주간빌드
2. 의존 관계 비순환 원칙(ADP: Acyclic-Dependencies Principle)

### 주간 빌드
모든 개발자는 한 주의 4일 동안은 다른 개발자를 신경 쓰지 않고 개발한다. 그런 다음 금요일에 그동안 변경한 것들을 모두 통합하고 시스템을 빌드해본다.  
불행하게도 프로젝트가 커지면 커질수록 금요일에 통합을 마무리 지을 가능성이 줄어든다.  

### 의존 관계 순환을 없애기
개발 환경을 릴리즈로 만들 수 있는 패키지로 분할하는 것이다.  
1. 패키지가 작업의 단위가 되고, 개발자나 팀은 패키지를 체크아웃해서 작업한다. 
2. 개발자가 어떤 패키지를 동작하게 만들면, 다른 개발자가 쓸 수 있도록 릴리즈한다.
3. 패키지가 새로 릴리즈되면, 다른 팀은 릴리즈를 채택할지 결정한다.
4. 따라서 어떤 팀도 다른 팀에 의해 좌지우지되지 않는다. 패키지의 새 릴리즈를 채택할지 말지 스스로 결정할 수 있다.  
  
이 방법은 **의존 관계 구조에 순환이 있으면 안 된다**.  
![KakaoTalk_Photo_2024-05-20-23-40-21](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/4790577f-62f9-4183-8957-048b6b8cba25)
 - 위의 그림이 방향 그래프라는걸 눈여겨보자.
 - 이 구조에서는 어떤 패키지에서 시작하더라도 의존 관계를 따라가서 다시 같은 패키지에 도달할 수 없다. 비순환 방향그래프다.

### 패키지 의존 관계 그래프에 순환이 있을 경우 생기는 결과
![KakaoTalk_Photo_2024-05-20-23-44-15](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/74f6a810-b493-4bd9-863b-9eb1673037d8)
순환이 이렇게 생기자마자 문제가 생긴다. 예를들면..  
 - MyTasks의 개발자들은 자기 패키지를 릴리즈 하려면 Task, MyDialogs, Database, Windows와 잘 맞아야 했다. 하지만 이제 순환이 있으므로 MyApplication, TaskWindow, MessageWindow와도 잘 맞아야 한다. 이 말은 이제 MyTask는 **시스템의 나머지 모든 패키지에 의존**한다는 뜻.
 - MyDialogs 패키지를 테스트하려고 할 때 Database 패키지까지 포함해서 시스템의 모든 패키지를 링크해야 한다는 사실을 발견. 즉, MyDialogs 하나 테스트해보려고 **전체 빌드**를 해야함.

### 순환을 끊기
두 가지 기본적인 방법이 있다. 
 - 의존 관계 역전 원칙(DIP)을 적용한다.
 - 문제가 생긴 MyDialogs와 MyApplication이 둘 다 의존하는 새로운 패키지를 만든다.
![KakaoTalk_Photo_2024-05-20-23-50-19 001jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/f2852114-623e-4b1b-8713-1717e80fb063)
![KakaoTalk_Photo_2024-05-20-23-50-20 002jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/099d4fed-7eb9-4a93-add1-14ff5bf796d2)

### 패키지 구성의 흔들림
애플리케이션이 성장하면서 패키지 의존 관계 구조도 이렇게 흔들리며 성장한다. 따라서 의존 관계 구조에 순환이 생기지 않는지 언제나 감시해야한다.

## 하향식 설계
패키지 구조는 하향식으로 설계할 수 없다?!  
사실 패키지 의존 관계 다이어그램은 애플리케이션 기능을 기술하는 일과는 거의 아무런 관계가 없다. 대신 이것은 애플리케이션의 **빌드 용이성**을 보여주는 일종의 지도이다.  
이것이 패키지 의존 관계가 프로젝트 초기에 설계되지 않는 이유임.  
클래스를 설계하기 전에 패키지 의존 관계 구조 설계를 먼저 시도하면 실패할 확률이 높다. 무슨 일이 일어날지 모르기 떄문에.. 따라서 패키지 의존 관계 구조는 시스템의 논리적 설계와 함께 성장하고 진화해야 한다.  


### 안정된 의존 관계 원칙(SDP: Stable-Dependencies Principle)
의존은 안정적인 쪽으로 향해야 한다.  
쉽게 바뀔 것이라고 예상되는 패키지들이 바뀌기 어려운 패키지들의 의존 대성이 되어서는 안된다.  
  
### 안정성
'쉽게 움직이지 않는다면 그것은 안정적이다' - 웹스터(Webster사전  
  
소프트웨어 패키지를 변경하기 힘들도록 만드는 요인에는 크기, 복잡도 명확성등 여러가지가 있지만 잠시 이런것을 무시하고,  
소프트웨어 패키지를 변경하게 힘들게 만드는 한 가지 확실한 방법은 다른 많은 소프트웨어 패키지가 그 패키지에 의존하게 만드는 것이다.  
![KakaoTalk_Photo_2024-05-24-23-30-16 001jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/54ca6e48-ecd2-4aef-b4c4-890dedab8572)
> 이 패키지는 자신에게 의존하는 패키지가 3개나 있으므로, 변경하지 말아야 할 이유가 3개나 있는셈  
> X는 나머지 3개 패키지에 '책임'이 있고, 다른 패키지에 의존하지 않음으로 '독립적'이다.
![KakaoTalk_Photo_2024-05-24-23-30-16 002jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/996c2ae2-e882-497a-90ae-25d29599c70d)
> 패키지 Y는 자신에게 의존하는 다른 패키지가 없다. Y는 책임이 없고, 패키지 3개에 의존하기 떄문에 변경의 가능성 외부원인이 3개 있다. Y는'의존적'임

### 안정성 측정법
패키지의 안정성은 어떻게 측정할까? 의존 관계 화살표를 세는 것이 한 방법임 **위치적 안정성**  
 - 들어오는 결합(Afferent Couplings Ca): 이 패키지에 들어 있는 클래스에 의존하는 패키지 외부 클래스의 수
 - 나가는 결합(Efferenct Couplings, Ce): 패키지 외부 클래스에 의존하는 패키지 내부 클래스의 수 
 - 불안정성(Instability, I)
![KakaoTalk_Photo_2024-05-24-23-39-21 001jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/25f86540-5e13-4663-902e-ed5d5cedc51a)
> 이 측정법으로 나오는 값의 범위는 [0, 1]임 I = 0일때 가장 안정적인 패키지  
  
ex)
![KakaoTalk_Photo_2024-05-24-23-39-22 002jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/6daf8ef0-f57c-4602-acf0-a9a4290e44ff)
> Pc 내부의 클래스에 의존하는 Pc외부의 클래스 수는 3개. 따라서 Ca = 3  
> Pc 내부의 클래스가 의존하는 외부 클래스의 수는 1개. 따라서 Ce = 1  
> I = 1/4  
> C++의 경우 의존 관계는 #Include로 봄
  
SDP에 따르면 어떤 패키지의 I 측정값은 그 패키지가 의존하는 다른 패키지들의 I값들보다 반드시 커야한다.(즉 의존 관계의 방향으로 I 측정값이 줄어들어야 한다.)

### 모든 패키지가 안정적일 필요는 없다
시스템에서 모든 패키지의 안정성이 가장 중요하다면, 시스템은 변경할 수 없게 될 것이며, 우리는 이것을 원하지는 않음.  
우리가 원하는건 어떤 패키지는 불안정하고, 어떤 패키지는 안정적인것  
![KakaoTalk_Photo_2024-05-24-23-49-29 001jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/c3d476d8-e2e5-4773-b706-4681153a979d)
> 변경 가능한 패키지들은 그림 위쪽에 있고 그림 아래 안정적인 패키지에 의존한다. 불안정한 패키지를 다이어그램 위에 그리는 습관을 갖자. 그렇게되면 화살표가 위로 향하면 SDP위반임을 알 수 있게 됨.  
![KakaoTalk_Photo_2024-05-24-23-49-29 002jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/99f742d0-3a22-4abd-ab30-fc7248a76e18)
> Flexible을 변경하기 쉬운 불안정한 패키지로 만드려했지만 Stable이 Flexible에 의존성이 걸려버렸다. 그 결과 Stable's I < Flexible's I 가 되버림  
![KakaoTalk_Photo_2024-05-24-23-49-29 003jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/04f82487-5345-403e-9fba-63ad9beb1dbb)
> 이런 이유로 의존성이 걸렸던거였으면?
![KakaoTalk_Photo_2024-05-24-23-49-30 004jpeg](https://github.com/WBBookStudy/AgileSoftwareDevelopment/assets/60125719/943ee337-3e78-4e62-b496-a1ff67821e3c)
> DIP로 해결하자. 이런식으로 구현하면 I가 줄어드는 방향으로 흐른다.

### 높은 차원의 설계는 어디에 두어야 하는가?
시스템의 일부 소프트웨어는 시스템 아키텍처와 설계 결정을 반영한다. 이런 결정들이 쉽게 바뀌길 원하는 사람은 없음.  
시스템에서 높은 차원의 설계를 캡슐화한 소프트웨어는 안정적인 패키지(I = 0)에 넣어야 한다. 불안정한 패키지(I = 1)는 변경될 가능성이 높은 소프트웨어만 포함해야 한다.  
하지만 높은 차원의 설계가 안정적인 패키지에 들어간다면 변경이 어려워진다.  
어떻게 해야 최고로 안정적인(I = 0)패키지를, 변화를 견딜 수 있을 정도로 만드나? -> OCP를 지키면 해결됨. -> 추상클래스가 답이다. 

## 안정된 추상화 원칙(SAP)
는 내일..
































