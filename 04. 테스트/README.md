# 04. 테스트
하나의 단위 테스트를 작성하는 일은 단순한 검증이라기보다는 설계의 문제다. 또한 단순한 검증이라기보다는 문서화의 문제이기도 하다.  

## 테스트 주도 개발
프로그램을 설계하기전에 먼저 테스트를 설계하면 어떨까? 이런 방식이 개발하던 소프트웨어의 설계에 주는 효과는 무엇일까?  
일차적이고 가장 명백한 효과는 프로그램의 모든 단일 함수가 그 동작을 검증하는 테스트를 갖게 된다는 것이다.  
이 테스트 집합은 이후의 개발을 위한 뒷받침이 되어, 기존의 어떤 기능을 망가뜨릴 때마다 그 사실을 알려주고 프로그래머는 뭔가 중요한 것을 망가뜨릴 걱정 없이 함수를 추가하거나 구조를 바꿀 수 있다.  
명백하진 않지만 더 중요한 효과는, 테스트를 먼저 작성할 경우 프로그래머가 다른 관점에서 문제를 해결할 수 있다는 것이다.  
테스트를 먼저 작성함으로서, 프로그래머는 **편리하게 호출할 수 있는** 소프트웨어를 설계할 수 있다. 또한 자신이 반드시 테스트 가능한 프로그램을 설계하도록 강제할 수 있다.  
소프트웨어가 호출 가능하고 테스트 가능해지려면 주위 환경에서 분리되어야 한다.  
테스트를 먼저 작성한다는건 **프로그래머가 소프트웨어를 다른 환경과 분리하도록 강제**하는 것이다.  
또 다른 효과로는 테스가 문서화의 귀중한 한 형태로 가능할 수 있다는 것이다.  
이 문 서화는 컴파일 및 실행이 가능하며, 항상 최근의 상태를 반영하고 거짓을 보여줄 수도 없다.  

### 테스트 우선 방식 설계의 예
로버트 마틴이 만든 간단한 게임을 예시로 들었는데, 이 게임은 동굴을 돌아다니며 움퍼스에게 잡아 먹히기 전에 먼저 움퍼스를 처치하는 간단한 게임이다.  
동굴은 통로로 연결되어있는 방의 집합으로 되어 있고, 각방에는 동서남북으로 향하는 통로가 있다. 플레이어는 컴퓨터에게 어느 방향으로 갈지를 알려서 움직인다.  
이 프로그램을 위해 만든 테스트중 하나인 testMove라는 코드를 보자
```JAVA
public void testMove() {
  WumpusGame g = new WumpusGame();
  g.connect(4,5,"E");
  g.setPlayerRoom(4);
  g.east();
  assertEquals(5, g.getPlayerRoom());
}
```
이 코드는 프로그램의 어떤 부분보다 먼저 작성했고, 위드 커닝햄의 조언을 받아 내용만 전달하는 방식으로 테스트를 작성했다 한다.  
이 테스트가 내포하는 구조에 맞는 코드를 작성하기만 하면 이 테스트를 동작하게 할 수 있다고 믿었다.  
이런것을 **계획된 프로그래밍(intentional programming)** 이라 하는데, 프로그래머는 자신의 의도를 구현하기 전에, 먼저 그 의도를 가능한 단순하고 읽기 편하게 만들어 테스트로 제시한다.  
그리고 이 단순성과 명쾌함이 바로 프로그램의 좋은 구조를 의미한다고 믿는다.  
한 방을 다른 방과 **연결하는** 동작은 프로그래머의 의도를 전달하는데, 그 전달을 쉽게하기 위해 Room클래스가 필요하지는 않은것 같다고 한다.  
이것이 직관적이지 않을 수도 있다. 결국 이 프로그램은 전부 방사이를 이동하고 무엇이 있는지를 확인하는 것처럼 전부 방에 관련된 것처럼 보일 수도 있다.  
로버트 마틴은 연결의 개념이 방의 개념보다는 더 주된 것이라고 하며, 이 테스트가 문제를 해결하는 좋은 방식을 보여줄 것이라 주장한다.
요점은 이 테스트가 아주 이른 시기에 주요한 설계의 이슈를 명백하게 한다는 것이다.  
**테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.**  

## 테스트 분리
운영코드를 만들기 전에 테스트를 먼저 작성할 경우, 소프트웨어에서 분리해야 할 부분이 드러나곤 한다.
![KakaoTalk_20231225_142006551](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/4be6f54c-971e-4fb3-b687-5903369ae799)
다음 그림을 보면, Payroll클래스는 EmployeeDatabase클래스를 이용해 Employee 객체를 꺼낸다.  
Employee에 자신의 임금을 계산하도록 요청하고, CheckWriter객체에 그 임금을 넘겨주어 수표를 만든다.  
마지막으로, Employee객체에 임금을 지급하고 그 객체를 데이터베이스에 다시 기록한다.  
아직 어떤 코드도 작성하지 않았다고 가정했을때, 이제 Payroll 객체의 행위를 명시하는 테스트를 작성해야 한다.  
먼저 어떤 데이터베이스를 사용할 것인가? 두번째로 적절한 수표가 출력되는지 어떻게 검증 할 수 있는가?  
이 문제의 해결책은 의사객체(MOCK OBJECT) 패턴을 이용하는 것이다.  
Payroll의 모든 관련 요소 사이에 인터페이스를 추가하고 이 인터페이스를 구현하는 테스트 스텁(stub)을 생성할 수 있다.  
![KakaoTalk_20231225_142712538](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/82ec3cf2-ec3a-4f9a-bfec-f00cf4b12a48)
Payroll 클래스는 이제 EmployeeDatabase, CheckWriter, Employee와 서로 대화하는 인터페이스를 사용한다.  
그리고 이 인터페이스를 구현하는 3개의 의사 객체가 생성되었다. PayrollTest객체는 Payroll 객체가 이 의사 객체를 제대로 관리하고 있는지 확인하기 위해 의사 객체에 질의한다.  
```JAVA
public void testPayroll() {
  MockEmployeeDatabase db = new MockEmployeeDatabase();
  MockCheckWriter w = new MockCheckWriter();
  Payroll p = new Payroll(db, w);
  p.payEmployees();
  assertTrue(w.checksWereWrittenCorrectly());
  assertTrue(db.paymentsWerePostedCorrectly());
}
```
다음 코드는 테스트가 내포하는 의도를 보여주는데, 이 테스트는 적절한 의사 객체를 생성하고, 그것을 Payroll 객체에 넘겨준다.  
그리고 Payroll 객체에게 모든 직원의 임금을 지불하라고 한 다음, 의사 객체에 모든 수표가 올바르게 작성됐는지, 모든 임금이 올바르게 지급됐는지 검증해달라는 요청을 한다.  
이 테스트가 검사하는 것은 Payroll이 전부 옳은 데이터로 옳은 함수를 호출하는지의 여부로, 수표가 제대로 작성됐는지를 검사하는 것은 아니다.  
데이터베이스가 제대로 갱신됐는지도 검사하지 않는다. 그보다는 Payroll 클래스가 분리된 것처럼 동작하는지 여부를 검사한다.  

### 운좋게 얻은 분리
Payroll을 다른 객체와 분리하는 것은 바람직한 일이다.  
명백하게, 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.  
**코드보다 테스트를 먼저 작성하면 설계가 개선된다.**  
이 책의 많은 부분은 의존성을 관리하기 위한 설계 원칙을 다루고 있는데, 이 원칙은 클래스와 패키지를 주위 환경으로부터 분리하기 위한 가이드라인과 테크닉을 제공할 것이다.  
이 원칙을 자신의 단위 테스트 전략의 일부로 이용하면 가장 이롭다는 사실을 알게 될 것이다.  
이것은 분리 작업을 위한 강한 동기와 방향을 제시하는 단위 테스트가 된다.  

## 인수 테스트
단위테스트는 필수적이지만 검증 툴로서는 불충분하다. 시스템의 작은 구성요소의 동작은 검증하지만 시스템이 전체로서 제대로 작동하는지는 검증하지 않는다.  
단위 테스트는 시스템의 개별적인 매커니즘을 검증하는 화이트박스 테스트 이며, 인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 블랙박스 테스트다.  
인수 테스트는 시스템의 내부 메커니즘을 알지 못하는 사람들이 작성하는데, 고객이 직접 작성하거나 고객과 연결된 기술관련 인력들이 작성할 수도 있다.  
인수 테스트는 기능 요소의 궁극적인 문서화 형태다.  
고객이 어떤 기능 요소가 제대로 되어 있는지 검증하는 인수 테스트를 작성하기만하면, 프로그래머는 인수테스트를 보고 정확하게 그 기능 요소를 이해할 수 있다.  
인수 테스트는 시스템의 기능 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행한다.  

### 인수 테스트의 예
급여 관리 애플리케이션에 대해 다시 한 번 생각해보자.  
첫번째 반복에서 데이터베이스에 직원을 추가하고 삭제할 수 있어야 한다. 또한 현재 데이터베이스에 있는 직원의 임금을 지급 수표로 만들 수 있어야 한다.  
다행히도 여기서는 월급을 주는 직원만 다루면 되며, 그 밖의 직원에 대한 처리는 이후의 반복까지 보류된다.  
아직 코드는 작성하지 않았고, 설계에도 시간을 들이지 않았다. 바로 지금이 인수 테스트에 대해 생각할 적기다.  
프로그래머는 자신이 생각하는 대로 구현되게끔 인수 테스트를 작성해야 한다. 그러고 나면 스크립트 언어를 구성하고 그 구조에 맞는 급여 관리 시스템을 만들 수 있다.  
작성하기 편하고, 변경하기 쉬운 인수 테스트를 만드는게 목표로 하자. 형상관리툴에 인수 테스트를 포함시키고 저장하여 내가 원할때마다 실행할 수 있기를 원한다.  
그러므로 인수 테스트를 단순한 텍스트 파일로 작성해야 한다는 생각은 일리가 있다.  
다음은 인수 테스트 스크립트의 한 예다.
```
AddEmp 1429 "Robert Martin" 3215.66
Payday
Verify Paycheck EmpId 1429 GrossPay 3215.88
```
이 스크립트의 흐름은
1. 직원번호 1429를 데이터베이스에 추가한다
2. 직원의 이름은 "Robert Martin"이고 월급은 3215.88달러다
3. 시스템에 오늘이 월급날이고 모든 직원에게 월급을 주어야 한다는 사실을 알려준다
4. 1429번 직원의 지급 수표가 GrossPay(총액) 필드 3215.88달러로 생성됐는지 확인한다

이런 종류의 스크립트는 고객이 작성하기에 아주 쉬울 것이다. 또한 새로운 기능성을 추가하기도 쉽다.  
이것이 시스템 구조에 관한 어떤 사실을 내포하고 있는지 생각해보자.  
이 스크립트의 처음 두 라인은 급여관리 어플리케이션의 기능으로서, 이 두 라인을 payroll 트랜잭션이라 부를 수 있다.  
이것은 급여 관리 시스템의 사용자가 기대하는 기능이다. 그러나 Verify 라인은 사용자가 기대한 트랜잭션이 아닌, 인수 테스트에 특화된 지시어다.  
이것은 이미 급여 관리 프로그램에 아키텍처와 관련된 긴장(stress)을 주게 된다.  
이 프로그램은 사용자로부터 직접 입력을 받아야 하고, 인수 테스트 프레임워크로부터 입력을 받아야 한다.  
그리고 프로그래머는 가능한 빨리 이 두가지 입력 경로를 하나로 모으고 싶어한다.  
그래서 하나 이상의 소스에서 오는 AddEmp와 Payday 형태의 트랜잭션을 처리할수 있는 처리기가 필요할 것이다.  
한가지 해결책은 급여 관리 애플리케이션에 XML로 된 트랜잭션을 보내는 것이다.  
인수 테스트 프레임워크는 물론 XML을 생성할 수 있을 것이고, 급여 관리 시스템의 UI도 XML을 생성 할수 있음 직하다.
```XML
<AddEmp PayType=Salaried>
  <EmpId>1429</EmpId>
  <Name>Robert Martin<Name>
  <Salary>3215.88</Salary>
</AddEmp>
```
인수 테스트 프레임워크가 어떻게 Verify 지시자를 실행할 수 있을까?  
급여 관리 애플리케이션이 지급 수표를 XML형식으로 생성하게 할 수 있다. XML에서 수표를 출력하는 마지막 단계는 수동으로 하는 인수 테스트로도 충분히 감당할 수 있을 만큼 평범한 일이 된다.  
그러므로 급여 관리 애플리케이션은 모든 지급 수표를 포함하는 XML 문서를 생성할 수 있다. 이 문서는 다음과 같다.  
```XML
<Paycheck>
  <EmpId>1429</EmpId>
  <Name>Robert Martin<Name>
  <GrossPay>3215.88</GrossPay>
</Paycheck>
```
인수 테스트 프레임워크는 텍스트 형식으로 트랜잭션을 읽어 XML로 번역하고, 다시 그것을 파일에 기록한다.  
그러고 나서 급여 관리 프로그램을 실행한 후, 마지막으로 급여 관리 프로그램에서 XML 출력 결과를 읽고 Verify 지시자를 실행한다.  

### 운 좋게 얻은 아키텍처
급여 관리 시스템 아키텍처의 인수 테스트가 주는 압박에 주목해보면, 테스트를 먼저 생각했다는 사실이 프로그래머를 XML 형식의 입력과 출력이란 개념으로 빠르게 연결되었다.  
이 아키텍처는 트랜잭션 소스를 급여 관리 애플리케이션으로부터 분리하고, 급료 지급 수표 출력 매커니즘을 급여 관리 애플리케이션으로부터 분리한다.  
이것은 아키텍처와 관련해 아주 바람직한 의사결정이다.  




