# 07. 애자일 설계란 무엇인가?
소프트웨어 프로젝트의 설계는 추상적인 개념으로, 구체적인 각 모듈, 클래스, 메소드의 형태와 구조뿐만 아니라 프로그램의 전체 형태와 구조와도 관련되어 있다.  
이것은 다양한 매체로 표현될 수 있지만, 최종적인 구현은 소스코드가 되고, 소스코드가 바로 설계다. 

## 소프트웨어에서 어떤 것이 잘못되는가?
소프트웨어는 상한 고기처럼 부패하기 시작해서, 시간이 지남에 따라 부패 범위가 넓어지고 심해진다.  
상처와 종기가 코드에 쌓이면서, 점점 더 유지보수 하기가 어려워지게 되고, 결국 개발자와 관리자는 재설계를 절실히 필요해지게 된다.  
그러나 이런 재설계는 성공하기가 어려운데, 성의를 가지고 시작했다 하더라도 자신이 계속 변하는 목표를 쏘고 있다는 사실을 곧 깨닫게 된다.  
기존 시스템은 계속 발전하고 변경되며, 새로운 설계는 그것을 쫓아가야 한다. 새로운 설계가 첫번째 릴리즈에 이르기도 전에 혹과 궤양이 새로운 설계에 생기는 셈이다.  

## 설계의 악취: 부패하고 있는 소프트웨어의 냄새
다음과 같은 냄새가 나기 시작하면 소프트웨어가 부패하고 있음을 알 수 있다.  
1. 경직성 : 시스템을 변경하기 어렵다. 변경을 하려면 시스템의 다른 부분들까지 많이 변경해야 하기 때문이다.
2. 취약성 : 변경을 하면 시스템에서 그 부분과 개념적으로 아무런 관련이 없는 부분이 망가진다.
3. 부동성 : 시스템을 다른 시스템에서 재사용할 수 있는 컴포넌트로 구분하기가 어렵다.
4. 점착성: 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더어렵다.
5. 불필요한 복잡성 : 직접적인 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.
6. 불필요한 반복 : 단일 추상 개념으로 통합할 수 있는 반복적인 구조가 설계에 포함되어 있다.
7. 불투명성 : 읽고 이해하기 어렵다. 그 의도를 잘 표현하지 못한다.

### 무엇이 소프트웨어의 부패를 촉진하는가?
애자일이 아닌 환경에서는 초기 설계에서 예상하지 않았던 요구사항 변경 때문에 설계가 퇴화하게 된다.  
설계를 변경할수는 있지만, 이건 원래의 설계를 위반하는 일이고, 이런 위반이 축적되면서 설계는 악취를 풍기기 시작한다.  
하지만 요구사항은 변경되기 마련이고, 우리는 요구사항이 프로젝트에서 가장 변덕스러운 요소임을 인식하고 있다.  
만약 계속되는 요구사항 변경 때문에 설계가 실패한다면, 우리의 설계와 방식에 문제가 있는 것이다.  
이런 변경에도 탄력적인 설계를 만드는 방식을 찾아야 하고, 보호할수 있는 방식을 사용해야 한다.

### 애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다
애자일 팀은 변경을 보람으로 삼고, 미리 노력을 한다.  
이것은 노화된 초기설계에 귀속되는 것이 아니라, 시스템의 설계를 가능한한 명료하고 단순하게 유지하고, 이것을 많은 단위 테스트와 인수 테스트 뒷받침한다.  
이런 작업을 통해 설계를 유연하고 변경하기 쉬운것으로 유지할 수 있다.  

## 'Copy'프로그램
만약 상사가 월요일 아침 일찍 키보드에서 프린터로 문자를 복사하는 프로그램을 작성하라고 요청했다 하자.  
실제 설계하고 코딩하는데는 한시간이 채 안걸리겠지만, 다른 미팅과 업무때문에 실제로 프로그램을 완성하는데 대략 1주 걸릴 것이다.  
그렇지만 우리는 예상한 시간에 3을 곱한 3주의 시간이 걸릴것이라 말하고, 업무를 시작한다.
#### 초기설계
우리는 다른 업무미팅 전에 시간이 조금 있어 프로그램의 설계를 그리기로 결심한다. 구조화된 설계를 사용하여 다음의 구조차트를 만들어낸다.  
![KakaoTalk_20240114_115323730](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/de73ac53-e6dc-457a-b3ad-38a56a39f87e)  
이 애플린케이션에는 3개의 모듈 또는 서브프로그램이 있고, Copy 모듈은 다른 2개를 호출한다.  
Copy 프로그램은 Read Keyboard 모듈에서 문자를 가지고와서 Write Printer 모듈에 보낸다. 이 설계를 보고 꽤 괜찮다고 생각한 후, 예정된 업무미팅을 위해 사무실을 떠난다.  
화요일에는 Copy 프로그램을 완성할 수 있게 되었다. 하지만 유감스럽게도 다른 위기 상황이 발생한 현장으로 나가 디버깅을 도와야 하는 상황이 생기게 된다.  
오후3시가 되어야 Copy프로그램을 그럭저럭 코드로 옮긴다.
``` C
void Copy() {
  int c;
  while((c = Rdkbd()) != EOF)
    WrtPrt(c);
}
```
편집한 내용을 저장하자마자, 예정된 품질관련 미팅에 늦었음을 깨닫고 그대로 급하게 자리를 떠난다.  
수요일에는 출근 후 별다른 일이 없으므로 Copy프로그램의 소스 코드를 뽑아 컴파일하기 시작하는데, 한번에 아무런 에러 없이 컴파일이 되었다.  
상사가 갑자기 업무 미팅에 호출하였고 그대로 수요일의 업무는 종료된다.  
목요일에는 원격 디버깅과 에러 기록명령을 할 수 있도록 기술 지원을 네시간 동안 하게된다.  
그후 Copy 프로그램을 테스트하는데 한번에 통과한다. 참 다행인게, 방금 새로 들어온 협력 학생이 서버에서 마스터 소스코드를 삭제해버려서, 가장 최근의 백업 테이프를 찾아 복구해야한다.  
금요일에는 다행히도 아무 예정도 없다. Copy 프로그램을 성공적으로 소스코드 관리 시스템이 넣는데는 하루가 꼬박 걸리게 된다.  
물론 이 프로그램은 대단히 성공해서 회사 전체에 널리 배포된다.

#### 요구사항 변경
몇달 후, 상사가 와서 Copy 프로그램이 종이테이프 판독기에서도 문자를 읽을 수 있으면 좋겠다고 말한다.  
우리는 Copy프로그램은 애초에 종이 판독기를 위해 설계된게 아니고, 프로그램 설계의 우아함을 망가뜨릴 수 있다고 상사에게 경고한다.  
하지만 상사는 완고하게 꼭 필요한 기능이라고 말하고, 결국 우리는 한숨을 쉬며 수정 작업의 계획을 수립한다.  
Copy 함수에 불리언 타입 인자를 추가하여, 그것이 참이면 종이테이프 판독기에서 읽어오고, 거짓이면 이전과 마찬가지로 키보드에서 읽어오는 식으로 수정하려 한다.  
유감스럽게도 Copy프로그램을 사용하는 프로그램이 많아 인터페이스를 변경할 수가 없다. 그래서 인터페이스를 변경하는 것은 취소하기로 한다.  
대신 전역변수를 사용하여, C계열 언어에서 가장 훌륭하고 유용한 기능인 ?: 연산자를 사용할 것이다.  
``` C
bool ptFlag = false 
void Copy() {
  int c;
  while((c = (ptFlag ? rdPt() : Rdkbd())) != EOF)
    WrtPrt(c);
}
```
수정이 다 끝나면 우리는 다시 한번 칭찬을 받으며 소프트웨어를 공개한다.

#### 한치를 주니
몇 주가 지나고 상사는 또 우리에게 Copy 프로그램으로 종이테이프 천공기에 출력을 하고 싶어한다는 얘기를 한다.  
**아마도 고객을 생각하지 않고 만든다면 소프트 웨어 작성은 훨씬 쉬울 것이다!**
또 다시 위험성에 대해 상사에게 경고하지만, 역시나 변경하라고 말한다.  
이번의 설계변경은 이전과 유사하고, 필요한것은 오직 또 다른 전역변수와 ?: 연산자 뿐이다.  
``` C
bool ptFlag = false
bool punchFlag = false 
void Copy() {
  int c;
  while((c = (ptFlag ? rdPt() : Rdkbd())) != EOF)
    punchFlag ? WrtPunch(c) : WrtPrt(c);
}
```
프로그램 구조가 비틀거리기 시작했다는 것이 불안하다. 입력장치에 또 다른 변경사항이 생기면 분명히 while 루프 조건문을 완전히 재구성해야 할 것이다.  
이력서를 꺼내어 먼지를 털때가 된듯하다.  

#### 변화를 예상하라
이 이야기의 요점은 변경이 발생할 때 프로그램의 설계가 얼마나 빨리 퇴화할 수 있는지를 보여주는데 있다.  
Copy 프로그램의 설계는 간단하고 우아했지만 단 두번의 변경 후에 **경직성, 취약성, 부동성, 복잡성, 반복, 불투명성**의 신호를 보여주기 시작했다.  
이런 경향은 계속될 것이고, 끝내 프로그램은 엉망이 될것이다.  
우리는 이게 변경 때문이라고 탓할수도 있지만, 이런 변명은 소프트웨어 개발에서 가장 중요한 요소중 하나를 무시한 말인데, **요구사항은 언제나 바뀐다.**  
> 우리는 변하는 요구사항의 세계에 살고 있고, 우리가 만든 소프트웨어가 이런 변화속에서 살아남을 수 있게 만드는 것이 바로 우리가 해야 하는 일이다.

만약 소프트웨어의 설계가 요구사항 변경 때문에 퇴화한다면, 우리는 애자일 방식대로 하고 있지 않은 것이다.

### Copy 프로그램의 애자일 설계
상사가 애자일 개발자에게 동일한 요구를 할때, 그들은 그런 종류의 변경도 탄력적으로 수용할 수 있도록 설계를 변경하는 방법을 썼을 것이다.  
``` C
class Reader {
  public : virtual int read() = 0;
}

class KeyboardReader : public Reader {
  public :virtual int read() {
    return Rdkbd();
  }
}

KeyboardReader GdefaultReader;

void Copy(Reader & reader = GdefaultReader) {
  int c;
  while((c = reader.read()) != EOF)
    WrtPrt(c);
}
```
새로운 요구사항을 만족시키기 위해 설계를 땜질하는 대신, 설계를 개선할 수 있는 기회를 잡아 미래에 있을 비슷한 종류의 변경에도 탄력적이 되도록 만든다.  
애자일팀은 **개방 폐쇄 원칙(OCP)** 을 따른다. 이 원칙은 프로그래머가 모듈을 수정하지 않고도 설계를 확장하도록 이끈다.  
따라서 상사가 요구하는 새 입력 장치는 모두 Copy 프로그램을 수정하지 않고도 지원할 수 있다.  
처음에 모듈을 설계할때는 프로그램이 얼마나 변경될 것인지 예상하려고 하지 않았음을 주목하자.  
애자일팀은 요구사항이 변경된 다음에야 그와 같은 종류의 변경에 탄력적이 되도록 모듈의 설계를 바꾼다.  
이렇게 새로운 입력장치에 대한 처리를 끝내면, 누군가는 새로운 출력장치에 대한 처리를 하지 않았다고 할수도 있다.  
하지만 애자일 팀은 출력장치가 언젠가 변경될지 여부를 알수없고, 그런 추가적인 처리를 지금 한다는 건 현재 상태에서 아무런 목적도 없는 일이 될 것이다.  
나중에 이런 처리가 필요해졌을때 이를 쉽게 처리할 수 있다는것은 명백하기에, 지금 그것을 생각할 필요는 없다.  

### 애자일 개발자는 해야 할 일을 어떻게 알았는가?
위의 사례에서 애자일 개발자는 입력장치의 변경에 대응하기 위해 추상 클래스를 만들었다.  
어떻게 그런 방법을 알 수 있었을까? 이것은 객체 지향 설계의 기본적인 주의중 하나와 관계가 있다.  
Copy 프로그램의 초기 설계는 의존성의 **방향** 떄문에 유연하지 못했고 처음 차트를 다시 보면, Copy 모듈이 KeyBoardReader와 PrinterWriter에 직접 의존하는 것에 주목하자.  
Copy모듈은 상위 수준의 모듈로서, 애플리케이션의 정책을 결정하고 문자를 복사하는 방법을 알고 있다.  
따라서 하위 수준의 세부사항이 바뀔 때, 상위수준의 정책이 영향을 받게 된다.  
이런 유연하지 못한 성질이 밝혀지면, 애자일 개발자는 Copy모듈에서 입력장치로 향하는 **의존성을 거꾸로 뒤집어(의존 관계 역전 원칙:DIP)** Copy가 더 이상 입력장치에 의존하지 않도록 해야한다는것을 깨닫는다.  
그리고 스트래터지(STRATEGY) 패턴을 사용해 원하는 역전 작업을 처리한다. 간단히 말하자면 애자일 개발자는 다음과 같은 이유때문에 해야 할 일을 알고 있었다.  
1. 그들은 애자일 실천 방법을 따라 하며 문제를 찾아냈다.
2. 그들은 설계 원칙을 적용해 문제를 진단했다.
3. 그리고 적절한 디자인 패턴을 적용해 문제를 해결했다.

이와같은 소프트웨어 개발의 세 측면 사이에서 일어나는 상호작용이 바로 설계 작업이다.  

## 가능한 한 좋은 상태로 설계 유지하기
애자일 개발자는 설계를 가능한 한 적절하고 명료한 상태로 유지하기 위해 애쓴다.  
설계는 명료한 상태로 유지되어야 하고, 설계의 가장 중요한 표현인 소스코드 역시 명료한 상태로 유지되어야 한다.  
전문가적인 정신에 따라, 우리는 소프트웨어 개발자로서 코드가 부패되도록 내버려둘 수 없다.  

## 결론
결국 애자일 설계란 과정이지, 결과가 아니다.  
이것은 원칙, 패턴, 그리고 소프트웨어의 구조와 가독성을 향상하기 위한 방식의 연속적인 적용이다.  
모든 시점에서 시스템의 설계를 가능한 한 간단하고, 명료하고, 표현적으로 유지하려는 노력이다.
