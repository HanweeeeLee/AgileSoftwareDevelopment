# 18. 급여 관리 사례 연구: 반복의 시작
이 장에서는 간단한 일괄 임금 지급 시스템 개발과정의 첫번째 반복을 보여준다.  

## 소개
### 명세
다음은 첫 반복에 선택된 스토리에 대해 고객과 나눈 대화중 일부다.  
- 몇몇 직원은 시간제로 일한다. 이들은 직원 레코드의 한 필드인 시급에 따라 임금을 받는데, 매일 날짜와 일한 시간을 기록한 타임카드를 제출하고, 하루에 8시간 이상 일하면 초과 근무시간에 대해 1.5배를 받고, 매주 금요일마다 임금을 받는다.
- 몇몇은 고정된 월급을 받고, 매달 마지막 평일에 임금을 받는다. 월급액수는 직원 레코드의 한 필드가 된다.
- 일부는 별도로 판매량에 기반을 둔 수수료를 받는다. 이들은 날짜와 판매량이 기록된 판매 영수증을 제출하고, 수수료율은 직원 레코드의 한 필드가 된다. 이들은 격주로 임금을 받는다.
- 직원들은 임금을 받는 방법을 선택 할 수 있다.
- 몇몇 직원은 조합에 속해 있다. 이들의 직원 레코드에는 주당 조합비 비율을 나타내는 필드가 있으며, 이 조합비는 임금에서 공제되어야 한다. 또한 조합은 가끔 조합원 개인에게 공재액을 부과할 수도 있다. 이 공제액은 주 단위로 조합에 의해 제출되며, 해당 직원의 다음달 임금에서 공제되어야 한다.
- 급여관리 어플리케이션은 평일에 한번씩 실행되고 해당 직원에게 그날 임금을 지급한다. 이 시스템은 직원이 임금을 받을 날짜를 입력받아, 지정된 날짜 전에 마지막으로 임금을 받은날부터 지정된 날짜까지의 임금을 계산한다.

데이터베이스 스키마를 생성하는 것부터 시작하자.  
데이터베이스는 **구체적인 구현**이다. 데이터베이스에 대한 고려는 가능한 뒤로 미루어야 한다.  
너무 많은 애플리케이션이 처음부터 데이터베이스를 생각하고 설계되기 때문에 그 데이터베이스에 어쩔 수 없이 묶여 버린다.  
**본질의 확충과 지엽적인 것의 제거** 라는 추상화의 정의를 상기하자. 이 단계의 프로젝트에서 데이터베이스는 지엽적인 것으로, 그저 데이터를 저장하고 그것에 접근하는 기법, 그 이상도 이하도 아니다.  

## 유스케이스 분석
시스템의 데이터보다는 시스템의 행위를 생각하는 것에서부터 시작하자. 우리가 만들어내야 하는것은 시스템의 동작이다.  
시스템의 행위를 이해하고 분석하는 방법 중 하나는 유스케이스를 만들어 보는 것이다.  
유스케이스 분석을 수행할 때는 시스템의 사용자들이 시스템에 줄 수 있는 여러 종류의 자극을 알아내기 위해 사용자 스토리와 인수 테스트를 살펴보게 되고,  
그리고 나서 이 시스템이 이런 자극에 어떻게 반응하는지 알아내려고 한다.  
다음 반복을 위해 고객이 선택한 사용자 스토리들을 보자. 
1. 새 직원을 추가한다.
2. 직원을 삭제한다.
3. 타임카드를 기록한다.
4. 판매 영수증을 기록한다.
5. 조합 공제액을 기록한다.
6. 직원 정보를 변경한다(시급, 조합비 비율)
7. 당일을 위한 급여 프로그램을 실행한다.

이 사용자 스토리 각각을 상세화된 유스케이스로 변환하자. 지나치게 구체적으로 들어갈 필요는 없다. 각 스토리를 충족시키는 코드설계를 생각하는데 도움이 될 정도면 된다.  

### 직원 추가
#### 유스케이스 1: 새 직원 추가하기
새로운 직원은 AddEmp 트랜잭션을 받는것으로 추가된다. 이 트랜잭션은 직원의 이름, 주소, 직원번호를 포함하는데, 다음과 같은 세 가지 형식이 있다.
```
AddEmp <직원번호> "<이름>" "<주소>" H <시급>
AddEmp <직원번호> "<이름>" "<주소>" S <월급>
AddEmp <직원번호> "<이름>" "<주소>" C <월급> <수수료율>
```
이 직원의 레코드 필드는 적절히 값이 할당되어 생성된다.
##### 대안: 트랜잭션 구조에서의 에러
트랜잭션 구조가 부적당하다면, 에러 메시지를 출력하고 아무 동작도 하지 않는다.

  
유스케이스 1은 추상화를 암시한다. AddEmp 트랜잭션에는 세가지 형식이 있지만, 모든 형식에는 <직원번호>, <이름>, <주소> 필드가 공통적으로 있다.  
커맨드 패턴을 이용해 3개의 파생클래스 AddHourlyERmployeeTransaction, AddSalariedERmployeeTransaction, AddCommissionedERmployeeTransaction을 갖는 기반클래스 AddERmployeeTransaction을 만들 수 있다.  
![KakaoTalk_20240414_132609513](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/45f2d420-cb10-42fa-b684-0dcd429a3a87)
이 구조는 각각의 일을 독자적인 클래스에 나누어 맡김으로서, SRP를 지키고 있다.  
그 밖의 대안으로, 이 모든 일을 하나의 모듈에 맡길 수도 있는데, 이 방법은 시스템에 있는 클래스의 수를 감소시켜 시스템이 더 간단해질 수는 있겠지만,  
모든 트랜잭션 처리 코드를 한곳에 집중시켜 거대하고 잠재적으로 에러가 발생하기 쉬운 모듈을 만들어낸다.  
각기 다른 3개의 트랜잭션이 만들어내는 것은 무엇인가?  
이 트랜잭션들은 서로 다른 세가지 종류의 직원 객체를 만들면서 서로 다른 세가지 종류의 AddEmp 트랜잭션을 흉내내고 있다. 다음은 가능한 구조를 보여준다.  
![KakaoTalk_20240414_134034339](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/1e123d2d-8dd8-4441-8fa1-54529834434f)

### 직원 삭제
#### 유스케이스 2: 직원 삭제하기
DelEmp 트랜잭션을 받으면 직원을 삭제한다. 이 트랜잭션의 형식은 다음과 같다.  
```
DelEmp <직원번호>
```
이 트랜잭션을 받으면 해당하는 직원레코드가 삭제된다.  

##### 대안: 유효하지 않거나 알 수 없는 직원번호
<직원번호> 필드가 맞게 구성되어 있지 않거나 유효한 직원 레코드를 가리키지 않으면, 이 트랜잭션은 에러메시지를 출력하고 아무 동작도 하지 않는다.  

    
이 유스케이스는 설계에 관해 지금은 아무 영감도 주지 않으므로 넘어가자.

### 타임카드 기록
#### 유스케이스 3: 타임카드 기록하기
TimeCard 트랜잭션을 받으면 시스템은 타임카드 레코드를 하나 생성하고, 이것을 해당하는 직원 레코드에 연결한다.  
```
TimeCard <직원번호> <날짜> <시간>
```
##### 대안 1: 선택된 직원이 시간제로 일하지 않는 경우
##### 대안 2: 트랜잭션 구조에서의 에러
시스템은 적절한 에러 메시지를 출력하고 더 이상의 동작은 취하지 않는다.  

  
이 유스케이스는 어떤 트랜잭션은 특정한 부류의 직원에 대해서만 쓸 수 있음을 나타낸다. 
이는 서로 다른것은 서로 다른 클래스에 의해 표현되어야 한다는 아이디어를 강화하는 것이다.  
여기서 타임카드와 시간제 직원사이에는 어떤 관계가 있는데, 이 관계를 나타냄직한 정적 모델은 다음과 같다.  
![KakaoTalk_20240414_134652001](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/8fbf815e-3547-4e31-8642-b68d209ec63f)

### 판매 영수증 기록
#### 유스케이스 4: 판매 영수증 기록하기

### 조합 공제액 기록하기

### 직원 정보 변경

### 임금 지급일
