# 18. 급여 관리 사례 연구: 반복의 시작
이 장에서는 간단한 일괄 임금 지급 시스템 개발과정의 첫번째 반복을 보여준다.  

## 소개
### 명세
다음은 첫 반복에 선택된 스토리에 대해 고객과 나눈 대화중 일부다.  
- 몇몇 직원은 시간제로 일한다. 이들은 직원 레코드의 한 필드인 시급에 따라 임금을 받는데, 매일 날짜와 일한 시간을 기록한 타임카드를 제출하고, 하루에 8시간 이상 일하면 초과 근무시간에 대해 1.5배를 받고, 매주 금요일마다 임금을 받는다.
- 몇몇은 고정된 월급을 받고, 매달 마지막 평일에 임금을 받는다. 월급액수는 직원 레코드의 한 필드가 된다.
- 일부는 별도로 판매량에 기반을 둔 수수료를 받는다. 이들은 날짜와 판매량이 기록된 판매 영수증을 제출하고, 수수료율은 직원 레코드의 한 필드가 된다. 이들은 격주로 임금을 받는다.
- 직원들은 임금을 받는 방법을 선택 할 수 있다.
- 몇몇 직원은 조합에 속해 있다. 이들의 직원 레코드에는 주당 조합비 비율을 나타내는 필드가 있으며, 이 조합비는 임금에서 공제되어야 한다. 또한 조합은 가끔 조합원 개인에게 공재액을 부과할 수도 있다. 이 공제액은 주 단위로 조합에 의해 제출되며, 해당 직원의 다음달 임금에서 공제되어야 한다.
- 급여관리 어플리케이션은 평일에 한번씩 실행되고 해당 직원에게 그날 임금을 지급한다. 이 시스템은 직원이 임금을 받을 날짜를 입력받아, 지정된 날짜 전에 마지막으로 임금을 받은날부터 지정된 날짜까지의 임금을 계산한다.

데이터베이스 스키마를 생성하는 것부터 시작하자.  
데이터베이스는 **구체적인 구현**이다. 데이터베이스에 대한 고려는 가능한 뒤로 미루어야 한다.  
너무 많은 애플리케이션이 처음부터 데이터베이스를 생각하고 설계되기 때문에 그 데이터베이스에 어쩔 수 없이 묶여 버린다.  
**본질의 확충과 지엽적인 것의 제거** 라는 추상화의 정의를 상기하자. 이 단계의 프로젝트에서 데이터베이스는 지엽적인 것으로, 그저 데이터를 저장하고 그것에 접근하는 기법, 그 이상도 이하도 아니다.  

## 유스케이스 분석
시스템의 데이터보다는 시스템의 행위를 생각하는 것에서부터 시작하자. 우리가 만들어내야 하는것은 시스템의 동작이다.  
시스템의 행위를 이해하고 분석하는 방법 중 하나는 유스케이스를 만들어 보는 것이다.  
유스케이스 분석을 수행할 때는 시스템의 사용자들이 시스템에 줄 수 있는 여러 종류의 자극을 알아내기 위해 사용자 스토리와 인수 테스트를 살펴보게 되고,  
그리고 나서 이 시스템이 이런 자극에 어떻게 반응하는지 알아내려고 한다.  
다음 반복을 위해 고객이 선택한 사용자 스토리들을 보자. 
1. 새 직원을 추가한다.
2. 직원을 삭제한다.
3. 타임카드를 기록한다.
4. 판매 영수증을 기록한다.
5. 조합 공제액을 기록한다.
6. 직원 정보를 변경한다(시급, 조합비 비율)
7. 당일을 위한 급여 프로그램을 실행한다.

이 사용자 스토리 각각을 상세화된 유스케이스로 변환하자. 지나치게 구체적으로 들어갈 필요는 없다. 각 스토리를 충족시키는 코드설계를 생각하는데 도움이 될 정도면 된다.  

### 직원 추가
#
#### 유스케이스 1: 새 직원 추가하기
새로운 직원은 AddEmp 트랜잭션을 받는것으로 추가된다. 이 트랜잭션은 직원의 이름, 주소, 직원번호를 포함하는데, 다음과 같은 세 가지 형식이 있다.
```
AddEmp <직원번호> "<이름>" "<주소>" H <시급>
AddEmp <직원번호> "<이름>" "<주소>" S <월급>
AddEmp <직원번호> "<이름>" "<주소>" C <월급> <수수료율>
```
이 직원의 레코드 필드는 적절히 값이 할당되어 생성된다.
##### 대안: 트랜잭션 구조에서의 에러
트랜잭션 구조가 부적당하다면, 에러 메시지를 출력하고 아무 동작도 하지 않는다.
#
  
유스케이스 1은 추상화를 암시한다. AddEmp 트랜잭션에는 세가지 형식이 있지만, 모든 형식에는 <직원번호>, <이름>, <주소> 필드가 공통적으로 있다.  
커맨드 패턴을 이용해 3개의 파생클래스 AddHourlyERmployeeTransaction, AddSalariedERmployeeTransaction, AddCommissionedERmployeeTransaction을 갖는 기반클래스 AddERmployeeTransaction을 만들 수 있다.  
![KakaoTalk_20240414_132609513](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/45f2d420-cb10-42fa-b684-0dcd429a3a87)
이 구조는 각각의 일을 독자적인 클래스에 나누어 맡김으로서, SRP를 지키고 있다.  
그 밖의 대안으로, 이 모든 일을 하나의 모듈에 맡길 수도 있는데, 이 방법은 시스템에 있는 클래스의 수를 감소시켜 시스템이 더 간단해질 수는 있겠지만,  
모든 트랜잭션 처리 코드를 한곳에 집중시켜 거대하고 잠재적으로 에러가 발생하기 쉬운 모듈을 만들어낸다.  
각기 다른 3개의 트랜잭션이 만들어내는 것은 무엇인가?  
이 트랜잭션들은 서로 다른 세가지 종류의 직원 객체를 만들면서 서로 다른 세가지 종류의 AddEmp 트랜잭션을 흉내내고 있다. 다음은 가능한 구조를 보여준다.  
![KakaoTalk_20240414_134034339](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/1e123d2d-8dd8-4441-8fa1-54529834434f)

### 직원 삭제
#
#### 유스케이스 2: 직원 삭제하기
DelEmp 트랜잭션을 받으면 직원을 삭제한다. 이 트랜잭션의 형식은 다음과 같다.  
```
DelEmp <직원번호>
```
이 트랜잭션을 받으면 해당하는 직원레코드가 삭제된다.  

##### 대안: 유효하지 않거나 알 수 없는 직원번호
<직원번호> 필드가 맞게 구성되어 있지 않거나 유효한 직원 레코드를 가리키지 않으면, 이 트랜잭션은 에러메시지를 출력하고 아무 동작도 하지 않는다.  
#
    
이 유스케이스는 설계에 관해 지금은 아무 영감도 주지 않으므로 넘어가자.

### 타임카드 기록
#
#### 유스케이스 3: 타임카드 기록하기
TimeCard 트랜잭션을 받으면 시스템은 타임카드 레코드를 하나 생성하고, 이것을 해당하는 직원 레코드에 연결한다.  
```
TimeCard <직원번호> <날짜> <시간>
```
##### 대안 1: 선택된 직원이 시간제로 일하지 않는 경우
##### 대안 2: 트랜잭션 구조에서의 에러
시스템은 적절한 에러 메시지를 출력하고 더 이상의 동작은 취하지 않는다.  
#
  
이 유스케이스는 어떤 트랜잭션은 특정한 부류의 직원에 대해서만 쓸 수 있음을 나타낸다. 
이는 서로 다른것은 서로 다른 클래스에 의해 표현되어야 한다는 아이디어를 강화하는 것이다.  
여기서 타임카드와 시간제 직원사이에는 어떤 관계가 있는데, 이 관계를 나타냄직한 정적 모델은 다음과 같다.  
![KakaoTalk_20240414_134652001](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/8fbf815e-3547-4e31-8642-b68d209ec63f)

### 판매 영수증 기록
#
#### 유스케이스 4: 판매 영수증 기록하기
SalesReceipt 트랜잭션을 받으면 시스템은 새로운 판매 영수증 레코드를 하나 생성하고, 이것을 해당하는 직원에게 연결한다.  
```
SalesReceipt <직원번호> <날짜> <액수>
```
##### 대안 1: 선택된 직원이 판매 수수료를 따로 받는 직원이 아닌 경우
##### 대안 2: 트랜잭션 구조에서의 에러
시스템은 적절한 에러 메시지를 출력하고 더 이상의 동작은 취하지 않는다.  
#
이 유스케이스는 유스케이스 3과 아주 비슷한데, 다음 구조와 같은 의미를 갖는다.  
![KakaoTalk_20240414_134652001](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/4cef35dc-66d6-4e0c-bcba-7b0e0defde30)

### 조합 공제액 기록하기
#
#### 유스케이스 5: 조합 공제액 기록하기
이 트랜잭션을 받으면 시스템은 공제액 레코드 하나를 생성하고, 이것을 해당하는 조합원 레코드에 연결한다.  
```
ServiceCharge <직원번호> <액수>
```
##### 대안: 형식을 지키지 않은 트랜잭션
트랜잭션이 형식을 지키지 않았거나 <직원번호>가 실제로 존재하는 조합원을 가리키지 않으면, 이 트랜잭션은 적절한 에러 메시지와 함께 출력된다.
#
이 유스케이스는 직원번호로 조합원에게 접근하는 것이 아님을 보여준다.  
조합은 조합원들을 위한 고유의 식별번호 체계를 갖고 있다. 따라서, 시스템은 조합원과 직원을 연결 할 수 있어야 한다.  
이런 연결을 가능하게 하는 여러 방법이 있으므로, 임의로 결정하는 상황을 피하기 위해 이 결정은 뒤로 미루도록 하자.  
한가지 확실한 건, 조합원과 그들의 공제액 사이에는 직접적인 연관 관계가 있다.  
![KakaoTalk_20240414_135838311](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/f60cd689-5a8a-4b41-8c48-8f019f8936c5)

### 직원 정보 변경
#
#### 유스케이스 6: 직원 정보 변경하기
이 트랜잭션을 받으면 시스템은 해당하는 직원 레코드의 정보 중 하나를 변경한다. 이 트랜잭션에는 다양한 변형이 있을 수 있다.  
```
ChgEmp <직원번호> Name <이름>                                직원의 이름을 변경한다
ChgEmp <직원번호> Address <주소>                             직원의 주소를 변경한다
ChgEmp <직원번호> Hourly <시급>                              시급을 받는것으로 변경한다
ChgEmp <직원번호> Salaried <월급>                            월급을 받는것으로 변경한다
ChgEmp <직원번호> Commissioned <월급> <비율>                  수수료를 받는 것으로 변경한다
ChgEmp <직원번호> Hold                                      급여 담당자에게 맡겨놓는다
ChgEmp <직원번호> Direct <은행> <계좌>                        직접 임금을 받는다
ChgEmp <직원번호> Mail <주소>                                우편으로 받는다
ChgEmp <직원번호> Member <조합원번호> Dues <조합비 비율>          직원을 조합에 넣는다
ChgEmp <직원번호> NoMember                                  직원을 조합에서 뺸다
```
##### 대안: 트랜잭션 에러
이 트랜잭션의 구조가 정상적이 아니거나 <직원번호>가 실제 직원을 가리키지 않거나 <조합원번호>가 이미 조합원을 가리키고 있다면, 적합한 에러메시지를 출력하고 더 이상의 동작을 취하지 않는다.  
#

이 유스케이스는 변경되어야 하는 직원의 모든 면을 말해주기 떄문에 그 의미가 아주 크다.  
![KakaoTalk_Photo_2024-04-14-15-24-10](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/eda7ae3b-338d-4f06-8561-f0d4cbbee891)
위 구조를 확인해보면 Employee 클래스는 PaymentClassification이라는 이름의 스트래터지 클래스를 포함할 수 있고,
Employee 객체를 변경하지 않고도 PaymentClassification 객체를 변경할 수 있으므로 이는 이점이 된다.  
시간제 직원이 월급을 받는 직원으로 변경되면, 대응하는 Employee 객체의 HourlyClassification 객체는 SalariedClassification 객체로 대체된다.  
PaymentClassification 객체에는 세 가지의 변형 형태가 있다.  
HourlyClassification 객체는 시급 액수와 TimeCard 객체의 리스트를 갖고, SalariedClassification 객체는 월급 액수를 갖는다.  
CommissionedClassification 객체는 월급, 수수료율, SalesReceipt 객체의 리스트를 갖는다.  
직원을 삭제 할 때에는 TimeCard와 SalesReceipt도 같이 소멸되어야 한다고 생각하기 때문에 각 객체에서 합성 관계를 사용한다.  
지급 방법 또한 변경할 수 있어야 한다. 위 구조는 스트래터지 패턴을 사용하여 서로 다른 세 종류의 PaymentMethod 클래스를 파생시킴으로서 이 아이디어를 구현하고 있다.  
Employee 객체가 MailMethod 객체를 포함하면, 급료 지급 수표를 우편으로 받게되고 수표를 보낼 주소는 MailMethod 객체에 저장되어 있다.  
Employee 객체가 DirectMethod 객체를 포함하면 DirenctMethod 객체에 저장된 은행계좌에 직접 입금될 것이다.  
Employee 객체가 HoldMethod 객체를 포함하면 임금 수표는 찾아갈 때까지 급여 담당자에게 맡겨질 것이다.  
마지막으로 조합 회원에 널 오브젝트 패턴을 적용한다.  
각 Employee 객체는 두가지의 형식이 있는  객체를 포함한다.  
만약 Employee가 NoAffiliation 객체를 포함하면, 이 직원의 임금은 자신 외의 조직에 의해 조정되지 않는다.  
만약 Employee가 UnionAffiliation 객체를 포함하면, 이 직원은 UnionAffiliation 객체에 저장된 조합비와 공제액을 지불해야 한다.  
이와 같은 패턴사용은 이 시스템이 OCP를 잘 따르게 한다.  
Employee 클래스는 급여 지급방법, 급여종류, 조합종류의 변경에 대해 닫혀있고, Employee에 아무 영향을 주지 않고 새로운 방법과 종류, 조합의 종류를 추가할 수 있다.  
이 구조는 급여 시스템이 하는 모든 일의 핵심에 있다. 급여 관리 애플리케이션에는 다른 많은 클래스와 설계가 있겠지만 이것은 모두 이 기본구조에 비하면 부차적인 것이다.  
물론 이 구조는 정형화된 상태로 남지 않고, 다른 모든것과 마찬가지로 진화해나갈 것이다.  

### 임금 지급일
#
#### 유스케이스 7: 당일을 위한 급여 프로그램 실행하기
Payday 트랜잭션을 받으면, 시스템은 지정된 날짜에 임금을 받아야 할 직원을 모두 가려낸다.  
그리고 이들이 얼마의 액수를 받아야 하는지 결정하고, 이들이 선택한 지급 방식으로 임금을 지급한다.  
```
Payday <날짜>
```
#

이 유스케이스의 의도는 이해하기 쉽지만 이것이 구조에 미칠 충격을 생각하기란 간단하지 않다.  
먼저 Employee 객체는 자신의 임금을 계산하는 일이 어디에서 일어나는가? 이상적인 장소는 PaymentClassification 파생 클래스인 것처럼 보인다.
이 객체는 임금을 계산하는 데 필요한 레코드르 갖기 때문에, 아마 임금을 결정하는 메소드들을 갖고 있을 것이다.  
다음 그림은 이것이 어떻게 제대로 가능할 수 있는지를 나타내는 협동 다이어그램을 보여준다.  
![KakaoTalk_Photo_2024-04-14-16-30-34](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/d9776db1-9bf7-497e-9dca-ef8d31027244)
Employee 객체는 임금을 계산하라는 요청을 받으면 이 요청을 PaymentClassification 객체에 맡긴다.  
실제로 사용되는 알고리즘은 Employee 객체가 포함하는 PaymentClassification의 형에 좌우된다.  
다음 그림들은 가능한 세가지의 시나리오를 보여준다.  
![KakaoTalk_Photo_2024-04-14-16-33-06](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/7a112f12-f2c1-4be0-9fc6-421268839743)

## 복습: 무엇을 배웠는가?
지금까지 간단한 유스케이스 분석이 시스템 설계에 풍부한 정보와 영감을 제공해준다는 사실을 배웠다. 

## 잠재적인 추상화를 찾아서
OCP를 효과적으로 사용하기 위해서는, 애플리케이션 내에 잠재하는 추상화를 샅샅이 뒤져 찾아야한다.  
급여 관리 애플리케이션의 잠재적인 추상화는 무엇일까? 요구사항을 다시 살펴보면 다음과 같은 일반화에 대한 힌트를 준다. 
'모든 직원은 임금을 받는다. 하지만 서로 다른 체계에 따라 받는다.'  
여기서의 추상화는 '모든 직원은 임금을 받는다'이다. PaymentClassification의 모델은 이 추상화를 표현하고 있다.  

### 지급 주기 추상화
다른 추상화를 찾아보면 '매주 금요일마다 임금을 받는다', '그달의 마지막 평일에 임금을 받는다', '격주로 금요일마다 임금을 받는다'를 찾을 수 있다.  
이들은 '모든 직원은 어떤 지급 주기에 따라 임금을 받는다' 라는 또다른 일반성을 이끌어낸다.  
여기서의 추상화는 **지급 주기** 라는 개념이다. 어떤 Employee 객체에 특정 날짜가 그 직원이 임금을 받는날인지 물어볼 수 있어야 한다.  
요구사항은 어떤 직원의 지급 주기를 임금 분류와 연계 시키지만 이런 연계가 본질적인 것인가?  
요구사항이 내포하는 것처럼, 만약 지급 주기 문제를 PaymentClassification 클래스에 위임한다면, 지급주기 변경에 대해 닫혀 있을수 없게 된다.  
지급정책을 변경하면 지급 주기도 테스트해야 할 것이고, 지급 주기를 변경하면 지급정책도 테스트해야 할것이며 OCP와 SRP를 모두 위반하게 된다.  
이런 연계는 특정 지급 정책 변경이 어떤 직원의 지급 주기를 망가뜨리는 버그를 유발할 수 있고,  
이는 어떤 위치의 어떤 변경이라 해도 시스템에서 관계없는 어떤 부분에든 문제를 일으킬 수 있으리라 생각하게 되고 변경의 영향을 예측할 수 없음을 두려워하게 되는 것이다.  
다음 두 그림은 지급 주기 추상화의 정적인 모델과 동적인 모델을 보여준다.  
![KakaoTalk_Photo_2024-04-14-17-34-29](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/24b81a7e-4ac5-4baf-9de4-7485c249c7b2)
![KakaoTalk_Photo_2024-04-14-17-34-35](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/e660a1d1-c8e3-437b-a8a3-9f5060fb20a4)
Employee 클래스는 추상 PaymentSchedule 클래스를 포함하고, 임금을 지급해야 할 직원에 따라 세가지의 서로 다른 지급 주기 방식에 대응하는 PaymentSchedule의 변형이 세종류 있다.  

### 지급 방법
요구사항에서 만들어낼 수 있는 또다른 일반화는 '모든 직원은 어떤 방법에 의해 임금을 받을수 있다'이다.  
여기서의 추상화는 PaymentMethod 클래스고 이 추상화는 이미 표현되어 있다.  

### 조합
요구사항은 조합에 가입한 직원이 있음을 나타낸다. 그러나 직원의 임금에 청구분을 가진 단체가 조합만은 아닐 수도 있다.  
직원은 자선단체에 자동 납부 형식으로 기부하고 싶을 수도 있고, 전문직 협회의 회비를 자동 납부 형식으로 내고 싶을 수도 있다.  
그러므로 다음과 같이 '직원은 그 직원의 임금에서 자동으로 돈을 지급받는 많은 단체에 가입되어 있을 수 있다' 라고 일반화 할 수 있다.  
이에 대응하는 추상화는 이전에 나온 Affiliation 클래스이다. 그러나 이 설계는 우리가 필요하다고 생각하는 것에 딱 맞는 추상화는 아니다.  
다음 두 그림은 Affiliation 추상화를 표현하는 정적 모델과 동적 모델을 보여준다.  
![KakaoTalk_Photo_2024-04-14-17-44-10](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/56525a5b-4748-4030-b839-fde044642ae5)
Affiliation 객체의 리스트는 아무 단체에도 소속되지 않은 직원을 위해 널 오브젝트 패턴을 사용할 필요성을 미연에 제거했고,  
직원이 아무 단체에도 소속되어 있지 않다면 그 직원의 Affiliation 리스트는 그냥 비어 있을 것이다.

