# 08. 단일 책임 원칙(SRP)
단일 책임 원칙은 톰 드마르코와 메이릴 페이지 존스의 연구에서 설명된 것으로, 그들은 이것을 **응집도** 라 불렀다.  
그들은 응집도를 모듈 요소간의 기능적인 연관으로 정의했지만, 이번 장에서는 그 의미를 조금 달리하여 모듈이나 클래스의 변경을 야기하는 응집력에 대해 애기한다.  

## 단일 책임 원칙(SRP)
> 한 클래스는 단 한가지의 변경 이유만을 가져야 한다.

만약 한 클래스가 하나 이상의 책임을 맡는다면, 그 책임들은 결합된다.  
한 책임에 대한 변경은 다른 책임을 충족시키는 클래스의 능력을 떨어뜨리거나 저하시킬 수도 있다.  
이런 종류의 결합은 변경을 했을 때 예상치 못한 방식으로 잘못 동작하는 취약한 설계를 유발한다.  
예를 들어 다음 설계를 보자.
![KakaoTalk_20240114_130105909](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/5352c0db-e3d4-4475-ade2-ec48b0a68648)
Rectangle 클래스는 2개의 메소드를 갖는다. 하나는 화면에 직사각형을 그리는 것이고, 다른 하나는 직사각형의 넒이를 계산하는 것이다.  
각기 다른 두 애플리케이션이 Rectangle 클래스를 사용한다.  
하나는 계산 기하학을 위한 애플리케이션으로 Rectangle을 사용하여 도형의 수학적 계산을 돕지만 직사각형을 그리지는 않는다.  
다른 하나는 본질적으로 그래픽을 위한 애플리케이션이고, 계산 기하학 관련 동작을 하긴 하지만, 화면에 확실히 직사각형을 그린다.  
따라서 이 설계는 Rectangle클래스가 두 가지의 책임을 맡고 있으므로 단일 책임 원칙을 위반한다.  
이런 SRP 위반은 귀찮은 문제를 유발하는데, 첫번째는 기하학 애플리케이션에 GUI를 포함시켜야 한다. C++이라면 GUI는 링킹되어야 하고, 링킹 및 컴파일 시간, 메모리영역을 소비하게 될것이고,  
자바 어플리케이션이라면 GUI를 위한 .class파일들이 target플랫폼에 배포되어야 할것이다.
두번째로, 어떤 이유에서든 GraphicalApplication에서의 변경이 Rectangle의 변경을 유발한다면, 이 변경 때문에 ComputationalGeometryApplication을 재빌드, 재테스트, 재배포 해야 할지도 모른다.  
좀더 나은 설게는 두 가지 책임을 다음과 같이 2개의 완전히 다른 클래스로 분리해 넣는 것이다.  
![KakaoTalk_20240114_133812777](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/70bbb3f1-c1b1-4574-8d00-dfb392140999)
이 설계는 Rectangle에서 계산을 하는 부분을 GeometricRectangle 클래스로 옮겼다.  
이제 직사각형이 그려지는 방식에 대한 변경은 ComputationalGeometryApplication에 영향을 주지 않는다.  

### 책임이란 무엇인가?
SRP의 맥락에서, 우리는 책임(responsibility)을 '변경을 위한 이유'로 정의한다.  
만약 우리가 한 클래스를 변경하기 위한 한가지 이상의 이유를 생각할 수 있다면, 그 클래스는 한가지 이상의 책임을 맡고 있는 것이다.  
때로 이것은 알아내기가 어려운데, 우리는 책임을 묶어서 생각하는데 익숙해져 있기 때문이다.  
다음 Modem 인터페이스를 보자.  
``` JAVA
interface Modem {
  public void dial(String pno);
  public void hangup();
  public void send(char c);
  public char recv();
}
```
대부분은 이 인터페이스가 타당해 보인다는데 동의할 것이다. 이것이 선언하는 4개의 함수는 분명히 모뎀에 속한 기능을 표현한다.  
하지만 여기에는 연결관리와 데이터 통신이라는 2개의 책임이 보이는데, dial과 hangup 함수는 모뎀의 연결을 관리하는 반면, send와 recv 함수는 데이터를 주고받으며 통신한다.  
이 두 책임이 분리되어야 할까? 그건 애플리케이션이 어떻게 바뀌느냐에 달려있다.  
만약 애플리케이션이 연결 함수의 시그니처에 영향을 주는 방식으로 바뀐다면, send와 recv 를 호출하는 클래스는 좀더 자주 재컴파일 및 재배포 되어야 할것이므로 이 설계는 **경직성**의 악취를 풍기게 된다.  
이 경우 두 책임은 다음과 같이 분리되어야 한다.  
![KakaoTalk_20240114_134831355](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/eaabe06d-f620-4637-a358-33fd4895126e)
이러면 클라이언트 애플리케이션에서 2개의 책임이 결합되는 것을 피할 수 있다.  
한편 애플리케이션이 서로 다른 시간에 두 가지 책임의 변경을 유발하는 방식으로 바뀌지 않는다면, 이들을 분리할 필요는 없다.  
이 경우 분리하게 되면 오히려 **불필요한 복잡성**이란 악취를 풍기게 할 것이다.  
여기에 필연적인 결과가 있다. **변경의 축은 변경이 실제로 일어날 때만 변경의 축이다.**  
아무 증상도 없는데 이 문제에 SRP나 다른 원칙을 적용하는 것은 현명하지 못하다.  

### 결합된 책임 분리하기
위 그림에서 ModemImplementation 클래스의 두 책임을 결합된 상태로 나뒀다는 점에 주목하자.  
바람직한 일은 아니지만 모든 의존성은 필요악일 수 있다. 하드웨어나 OS의 세부적인 사항과 관련된 이유로 인해, 오히려 책임이 결합되도록 만드는 경우가 종종 있다.  
하지만 인터페이스는 분리하여 애플리케이션의 나머지 부분에 한해 개념을 분리했다.  
ModemImplementation 클래스를 어울리지 않는 요소나 혹으로 볼수도 있겠지만 모든 의존성 흐름이 여기에서 나간다는 사실에 주목하자. 아무것도 이 클래스에 의존하지 않는다.  
따라서 main외에 어느 것도 이것이 존재한다는 사실을 알 필요가 없고, 이 보기 싫은 부분은 새어나가 애플리케이션의 나머지 부분을 오염시킬 필요가 없다.  

### 영속성
다음 그림은 흔한 SRP 위반을 보여준다.
![KakaoTalk_20240114_135643761](https://github.com/jhkman/AgileSoftwareDevelopment/assets/50142323/ce547fa5-0c2b-4804-bb9e-f9e01f443286)
Employee 클래스는 업무 규칙과 영속성(같은 상태가 오래 계속되는 성질) 제어를 포함한다. 이 두 책임은 거의 어울리지 않을 것이다.  
업무 규칙은 자주 바뀌는 경향이 있고 영속성은 자주 바뀌지 않는 경향이 있지만, 바뀌는 이유도 완전히 다르다.  
업무 규칙과 영속성 서브시스템을 묶는 것은 문제를 부르는 것이나 다름없다.  
다행히도 테스트 주도 개발 방식은 보통 설계에서 악취가 나기 한참 전에 이 두 책임이 분리되도록 만들 것이다.  
하지만 테스트가 분리를 강제하지 않았고, **경직성**과 **취약성**의 악취가 강해진 경우에는, 이 설계에 퍼사드(FACADE)나 프록시(PROXY) 패턴을 사용해 두 책임이 분리되도록 리팩토링 해야 한다.  

## 결론
SRP는 가장 간단한 원칙중 하나임과 동시에 제대로 적용하기 가장 어려운 원칙 중 하나이기도 하다.  
책임들을 결합하는 것은 우리가 너무나 자연스럽게 해버리고 마는 일이고, 이런 책임을 찾고 하났끽 분리하는 것이 소프트웨어 설계에서 실제로 하는 일의 대부분이다.  
이후에 논하게 될 나머지 원칙들에서도 어떤식으로든 이 문제로 돌아오게 된다.


